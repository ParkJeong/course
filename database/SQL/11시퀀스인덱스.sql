-- 시퀀스 확인 명령
SELECT *
  FROM USER_SEQUENCES;
-- VIEW 확인 명령
SELECT *
  FROM USER_VIEWS;
-- 제약조건 확인명령
SELECT *
  FROM USER_CONSTRAINTS;

-- 시퀀스 (순차적으로 증가하는 값)
-- 시퀀스 생성
CREATE SEQUENCE DEPT_SEQ;
-- 시퀀스 삭제
DROP SEQUENCE DEPT_SEQ;

-- 옵션지정하고 시퀀스 생성  ,가 없다.
CREATE SEQUENCE DEPT3_SEQ
  INCREMENT BY 1
  START WITH 1
  MAXVALUE 10
  NOCYCLE
  NOCACHE;

-- 테이블 생성
CREATE TABLE DEPT3(
    DEPT_NO NUMBER(3) CONSTRAINT DEPT3_DEPT_NO_PK PRIMARY KEY,
    DEPT_NAME VARCHAR2(20),
    DEPT_DATE DATE DEFAULT SYSDATE
);

-- 시퀀스 사용하기 CURRVAL, NEXTVAL
-- 시퀀스 MAXVALUE가 10이기 때문에 10까지 증가되면 오류를 발생시킨다,
-- NEXTVAL가 어디에서 쓰이든지 한번 쓰이면 돌이킬 수 없다. SEQUENCE 값은 증가한 상태다.
INSERT INTO DEPT3(DEPT_NO, DEPT_NAME)
VALUES (DEPT3_SEQ.NEXTVAL, 'TEST');

-- 현재 시퀀스 확인
SELECT DEPT3.CURRVAL
  FROM DUAL;

-- 시퀀스 수정
-- ALTER SEQUENCE DEPT3_SEQ 옵션
-- EX
ALTER SEQUENCE DEPT3_SEQ MAXVALUE 9999; -- 맥스값 9999로 변경
ALTER SEQUENCE DEPT3_SEQ INCREMENT BY 10; -- 증가값 10으로 변경
ALTER SEQUENCE DEPT3_SEQ MINVALUE 1; -- 최소값 1로 변경

--시퀀스 조회
SELECT DEPT3_SEQ.CURRVAL
  FROM DUAL;
SELECT DEPT3_SEQ.NEXTVAL
  FROM DUAL;

DROP SEQUENCE DEPT3_SEQ;

-- 시퀀스 활용 PK값을 20201016-시퀀스값
/*
1.DEPT3_SEQ생성
2.PK를 VARCHAR2로 생성
3.INSERT실행 TO_CHAR() || - || 시퀀스 값
*/

INSERT INTO DEPT3
VALUES(TO_CHAR(SYSDATE, 'YYYYMMDD')||'-'||DEPT3_SEQ.NEXTVAL, 'TEST');

CREATE TABLE DEPT3(
    DEPT_NO VARCHAR2(30),
    DEPT_NAME VARCHAR2(30),
    CONSTRAINT DEPT3_DEPT_NO_PK PRIMARY KEY (DEPT_NO)
);

CREATE SEQUENCE DEPT3_SEQ
    INCREMENT BY 1
    START WITH 1
    MAXVALUE 100
    CYCLE
    NOCACHE;

INSERT INTO DEPT3
VALUES(TO_CHAR(SYSDATE, 'YYYYMMDD')||'-'||DEPT3_SEQ.NEXTVAL, 'TEST');

SELECT *
  FROM DEPT3;
  
  
  
--INDEX  
--INDEX는 PRIMARY KEY, UNIQUE 제약조건에서 자동으로 생성되고, 조회를 빠르게 해주는 HINT역할을 한다.
--INDEX는 조회를 빠르게 하지만, 너무 많은 인덱스를 생성해서 사용하면 오히려 성능 부하를 일으킬 수 있다.
--그래서 최후의 수단으로 INDEX를 사용하는 것이 올바른 사용방법
SELECT * FROM USER_INDEXES;

-- INDEX를 수동으로 추가
CREATE INDEX EMPS_FIRST_NAME_IX
ON EMPS(FIRST_NAME);

-- INDEX 삭제
DROP INDEX EMPS_FIRST_NAME_IX;