입출력은 장치에 따라 다르게 구현해야 한다. 자바는 장치에 따라 독립적이고 효율적인 입출력 기능을 제공한다.


스트림이란?
자바에서 모든 입출력은 스트림을 통해 이루어진다. 스트림이란 네트워크에서 유래된 용어이다. 자료 흐름이 물의 흐름과 같다는 의미에서 사용되었다. 입출력 장치는 매우 다양하기 때문에 장치에 따라 입출력 부분을 일일이 다르게 구현을 하면 프로그램 호환성이 떨어질 수 밖에 없다. 이런 문제를 해결하기 위해 자바는 입출력 장치와 무관하고 일관성 있게 프로그램을 구현할 수 있도록 일종의 가상 통로인 스트림을 제공하는 것이다. 자료를 읽어들이려는 소스(source)와 자료를 쓰려는 대상(target)에 따라 각각 다른 스트림 클래스를 제공한다.

     자바     --------------------------------  입출력
응용 프로그램         스트림(가상 통로)          자료
              --------------------------------

자바에서 입출력을 하려면 여러 스트림 클래스에 대해 알아야 한다. 하지만, 구현 방식이 서로 비슷하다. 스트림을 세 가지 기준에 따라 분류해보자.


1.입력 스트림과 출력 스트림
어떤 대상으로부터 자료를 읽어 들일 때 사용하는 스트림이 입력 스트림이다. 예를 들어 입력 스트림은 어떤 동영상을 재생하기 위해 동영상 파일에서 자료를 읽을 때 사용한다. 편집화면에 사용자가 쓴 글을 파일에 저장할 때는 출력 스트림을 사용한다. 스트림은 단방향으로 자료가 이동하기 때문에 입력과 출력을 동시에 할 수 없다. 따라서 어떤 스트림이 있다고 하면 그 스트림은 입력 스트림이거나 출력 스트림이다.

스트림의 이름을 보면 입력용인지 출력용인지 알 수 있다. InputStream이나 Reader로 끝나는 이름의 클래스는 입력 스트림이다. 반면에 OutputStream이나 Writer로 끝나는 이름의 클래스는 출력 스트림이다.

입력 스트림 
FileInputStream, FileReader, BufferedInputStream, BufferedReader 등
FileOutputStream, FileWriter, BufferedOutputStream, BufferedWriter 등


2. 바이트 단위 스트림과 문자 단위 스트림
원래 자바의 스트림은 바이트 단위로 자료의 입출력이 이루어진다. 그러므로 그림, 동영상, 음악 파일 등 대부분 파일은 바이트 단위로 읽거나 쓰면 된다. 그런데 자바에서 하나의 문자를 나타내는 char형은 2바이트이기 때문에 1바이트만 읽으면 한글 같은 문자는 깨진다. 따라서 입출력 중 가장 많이 사용하는 자료인 문자를 위해 문자 스트림을 별도로 제공한다. 즉 읽어 들이는 자료형에 따라 바이트용과 문자용 스트림이 있다.

     자바     --------------------------------  입출력
응용 프로그램       바이트 스트림(가상 통로)     자료
              --------------------------------


     자바     --------------------------------  입출력
응용 프로그램        문자 스트림(가상 통로)      자료
              --------------------------------

스트림 클래스의 이름이 Stream으로 끝나는 경우는 바이트 단위를 처리하는 스트림이다. Reader나 Writer로 끝나는 이름은 문자를 위한 스트림 클래스이다.

바이트 스트림
FileInputStream, BufferedInputStream
FileOutputStream, BufferedOutputStream

문자스트림
FileReader, BufferedReader
FileWriter, BufferedWriter


3. 기반 스트림과 보조 스트림
어떤 스트림이 자료를 직접 읽거나 쓰는 기능을 제공하는 스트림인가, 아니면 자료를 직접 읽거나 쓰는 기능은 없어 다른 스트림에 부가 기능을 제공하는가에 따라 기반 스트림과 보조 스트림으로 구분할 수 있다.
기반 스트림은 읽어 들일 곳(소스)이나 써야 할 곳(대상)에서 직접 읽고 쓸 수 있으며 입출력 대상에 직접 연결되어 생성되는 스트림이다. 
반면에 보조 스트림은 직접 읽고 쓰는 기능은 없다. 따라서 항상 다른 스트림을 포함하여 생성된다.

기반 스트림 (+ 보조 스트림 A (+ 보조 스트림 B))

기반 스트림
FileInputStream, FileOutputStream, FileReader, FileWriter

보조 스트림
InputStreamReader, OutputStreamWriter, BufferedInputStream, BufferedOutputStream

하나의 스트림 클래스는 세 가지 분류로 나눌 수 있다.




표준 입출력
자바에서는 화면에 출력하고 입력받는 표준 입출력 클래스를 미리 정의해 두었다. 이 클래스는 프로그램이 시작될 때 생성되므로 따로 만들 필요가 없다. System.out은 표준 출력을 위한 객체다. 표준 입출력은 콘솔 화면에 입출력된다고 해서 콘솔 입출력이라고도 한다. 표준 입출력을 위한 System 클래스는 아래와 같이 세 개의 변수를 가지고 있다.

자료형                변수 이름         설명
static PrintStream      out       표준 출력 스트림
static InputStream      in        표준 입력 스트림
static OutputStream     err       표준 오류 출력 스트림


System.in.read(); <- read() 메서드로 한 바이트 읽음


그 외 입력 클래스

Scanner 클래스
java.util 패키지에 있는 입력 클래스이다. Scanner 클래스는 문자뿐 아니라 정수, 실수 등 다른 자료형도 읽을 수 있다. 또한 콘솔 화면뿐 아니라 파일이나 문자열을 생성자의 매개변수로 받아 자료를 읽어 올 수 있다.

생성자                                         설명
Scanner(File source)         파일을 매개변수로 받아 Scanner를 생성한다.
Scanner(InputStream source)  바이트 스트림을 매개변수로 받아 Scanner를 생성한다.
Scanner(String source)       String을 매개변수로 받아 Scanner를 생성한다.

Scanner scanner = new Scanner(System.in)처럼 사용하면 표준 입력으로부터 자료를 읽어 들이는 기능을 사용할 수 있다.



Console 클래스
System.in을 사용하지 않고 간단히 콘솔 내용을 읽을 수 있는 Console 클래스도 있다. 직접 콘솔 창에서 자료를 입력받을 때 이 클래스를 사용하는데, 이클립스와는 연동되지 않는다.



바이트 단위 스트림

모두 외울 필요 없다. 기본 사용법을 익히고 나중에 프로그램을 개발할 때 원하는 기능의 클래스를 잘 찾아서 사용할 수 있으면 된다.

InputStream
바이트 단위로 읽는 스트림 중 최상위 스트림이다. InputStream은 추상 메서드를 포함한 추상 클래스로서 하위 스트림 클래스가 상속받아 각 클래스 역할에 맞게 추상 메서드 기능을 구현한다. 주로 사용하는 하위 클래스는 다음과 같다.


FileInputStream: 파일에서 바이트 단위로 자료를 읽는다.
ByteArrayInputStream: Byte 배열 메모리에서 바이트 단위로 자료를 읽는다.
FilterInputStream: 기반 스트림에서 자료를 읽을 때 추가 기능을 제공하는 보조 스트림의 상위 클래스이다.

파일에서 자료를 읽는 경우 파일의 끝에 도달하면 -1이 반환된다.


FileInputStream
FileInputStream은 파일에서 바이트 단위로 자료를 읽어 들일 때 사용하는 스트림 클래스이다. 스트림을 사용하기 위해서는 먼저 스트림 클래스를 생성해야 한다.

FileInputStream(String name): 파일 이름 name(경로 포함)을 매개변수로 받아 입력 스트림을 생성한다.
FileInputStream(File f): File 클래스 정보를 매개변수로 받아 입력 스트림을 생성한다.


public class FileInputStreamTest2 {
	public static void main(String[] args) {
		try(FileInputStream fis = new FileInputStream("input.txt")){
			int i;
			while((i = fis.read()) != -1) {
				System.out.println((char)i);
			}
			
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

public class FileInputStreamTest3 {
	public static void main(String[] args) {
		try(FileInputStream fis = new FileInputStream("input2.txt")){
			byte[] bs = new byte[10];
			int i;
			while((i = fis.read(bs)) != -1) {
				for(int k = 0; k < i; k++) {
					System.out.print((char)bs[k]);
				}
				System.out.println(": " + i + "바이트 읽음");
			}
		} catch(IOException e) {
			e.printStackTrace();
		}
		System.out.println("end");
	}
}

read() 메서드로 파일을 읽는 경우 파일의 끝에 도달하면 -1을 반환한다.
메서드의 반환 값은 프로그래밍할 때 유용하게 쓰인다. 반환 값도 잘알아 둘 것.



OuptStream
바이트 단위로 쓰는 스트림 중 최상위 스트림이다. 자료의 출력 대상에 따라 다른 스트림을 제공한다.

FileOutputStream: 바이트 단위로 파일에 자료를 쓴다.
ByteArrayOutputStream: Byte 배열에 바이트 단위로 자료를 쓴다.
FilterOutputStream: 기반 스트림에서 자료를 쓸 때 추가 기능을 제공하는 보조 스트림의 상위 클래스이다.


FileOutputStream
파일에 바이트 단위 자료를 출력하기 위해 사용하는 스트림이다.

FileOutputStream(String name): 파일 이름 name(경로 포함)을 매개변수로 받아 출력 스트림을 생성한다.
FileOutputStream(String name, boolean append): 파일 이름 name(경로 포함)을 매개변수로 받아 입력 스트림을 생성한다. append 값이 true이면 파일 스트림을 닫고 다시 생성할 때 파일의 끝에 이어서 쓴다. 디폴트 값은 false이다.
FileOutputStream(File f): File 클래스 정보를 매개변수로 받아 출력 스트림을 생성한다.
FileOutputStream(File f, boolean append): File 클래스 정보를 매개변수로 받아 출력 스트림을 생성한다. append 값이 true이면 파일 스트림을 닫고 다시 생성할 때 파일의 끝에 이어서 쓴다. 디폴트 값은 false이다.

생성자 매개변수로 전달한 파일이 경로에 없으면 FileOutputStream은 파일을 새로 생성한다. FileOutStream을 사용해 파일에 자료를 쓸 때 기존 파일의 내용이 있더라도 처음부터 새로 쓸지(overwrite), 아니면 기존 내용 맨 뒤에 연결해서 쓸 것인지(append) 여부를 FileOutputStream 생성자의 매개변수로 전달한다. 이 값이 append 변수이다. 스트림 생성자에서 append 값은 디폴트가 false이다. 기존에 쓰여 있는 내용이 잇더라도 새로 쓴다. 기존 파일 내용에 이어서 써야 한다면 append 값을 반드시 true로 지정한다.

public class FileOutputStreamTest {
	public static void main(String[] args) {
		try(FileOutputStream fos = new FileOutputStream("output.txt")){
			fos.write(65);
			fos.write(66);
			fos.write(67);
		} catch(IOException e) {
			e.printStackTrace();
		}
		
		System.out.println("출력이 완료되었습니다.");
	}
}

FileOutputStream은 숫자를 해당 아스키 코드 값으로 변환하여 저장한다. 만약 기존 자료에 이어서 출력하고 싶으면 생성자의 두 번째 매개변수에 true라고 쓴다.
fos = new FileOutputStream("output.txt", true);

public class FileOutputStreamTest2 {
	public static void main(String[] args) {

//try-with-resources문 활용		
//FileOutputStream fos = new FileOutputStream("output2.txt", true);
//try(fos) 
		try(FileOutputStream fos = new FileOutputStream("output2.txt", true)){
			byte[] bs = new byte[26];
			byte data = 65;
			for(int i = 0; i < bs.length; i++) {
				bs[i] = data;
				data++;
			}
			fos.write(bs);
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.println("출력이 완료되었습니다..");
	}
}

write(byte[] b, int off, int len)
배열의 전체 자료를 출력하지 않고 배열의 off 위치부터 len 길이만큼 출력한다.
write(bs, 2, 10)이라고 쓰면 bs 배열의 두 번째 인덱스, 즉 세 번째 위치부터 10개 바이트 자료만 출력한다. 

public class FileOutputStreamTest3 {
	public static void main(String[] args) {
		
		try(FileOutputStream fos = new FileOutputStream("output3.txt")){
			byte[] bs = new byte[26];
			byte data = 65;
			for(int i = 0; i < bs.length; i++) {
				bs[i] = data;
				data++;
			}
			fos.write(bs, 2, 10);
			
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.println("출력이 완료되었습니다...");
	}
}


flush() 메서드와 close() 메서드
출력 스트림에서 flush() 메서드의 기능은 강제로 자료를 출력하는 것이다. write() 메서드로 값을 썼다고 해도 바로 파일이나 네트워크로 전송되지 않고 출력을 위한 자료가 쌓이는 출력 버퍼에 어느 정도 자료가 모아야 출력된다. 따라서 자료의 양이 출력할 만큼 많지 않으면 write() 메서드로 출력했어도 파일에 쓰이지 않거나 전송되지 않을 수 있다. 이런 경우에 flush() 메서드를 호출한다. 출력 스트림의 close() 메서드 안에서 flish()메서드를 호출하여 출력 버퍼가 비워지면서 남아 있는 자료가 모두 출력된다.

바로바로 전송할 채팅 메시지 같은 경우는 flush() 메서드를 호출하는 것이 좋다.








정적 초기화자 static initializer
정적 초기화자는 static 변수들의 초기화에 사용한다. static 변수는 객체 생성 없이도 사용해야 하므로 생성자를 통해 초기화할 수 없다.

그래서 static 변수는 정적 초기화자를 통해 초기화를 한다.

정적 초기화자는 클래스가 로딩될 때 생성자와 main() 메서드에 앞서 오직 단 한번만 실행되기 때문에 애플리케이션 실행 중 반드시 한번만 실행되어야 할 로직이 있다면 이곳에 기술하여 사용될 수 있다.

public class Computer {
	public static String company;
	public static String model;
	public int price;
	
	// static 변수는 정적 초기화자에서 초기화
	static {
		company = "LG";
		model = "gram";
	}
	
	// 일반 멤버 변수만 생성자에서 초기화
	Computer(int price) {
		this.price = price;
	}
}

싱글톤패턴 : 객체가 1개만 생성되도록 클래스를 구성하는 방법












