상속(inheritance)

class A{
}
class B extends A {
}

A클래스가 B클래스에게 상속한다.
= B클래스가 A클래스를 상속받는다.

상위 클래스는 super class, base class
하위 클래스는 subclass, derived class로 표현하기도 한다.
부모 클래스(parent class)를 상위 클래스, 자식 클래스(child class)를 하위 클래스라고 부른다.

클래스 간 상속을 표현할 대는 위 그림에 표현한 것처럼 상속받는 클래스에서 상속하는 클래스로 화살표가 간다.

자바 문법으로 상속을 구현할 때는 extends 예약어를 사용한다.


class B extends A {

}
위의 코드는 'B클래스가 A 클래스를 상속받는다'라고 말한다.
class Mammal {
}
class Human extends Mammal {
}
포유류는 사람보다 일반적인 개념이다. 즉 사람은 포유류의 특징과 기능을 기본으로 더 많거나 다른 특징과 기능을 가지고 있다. 이렇게 상속 관계에서는 상위 클래스가 하위 클래스보다 일반적인 개념이고, 하위 클래스는 상위 클래스보다 구체적인 클래스가 된다.

하위 클래스에서는 상위 클래스에서 private으로 선언한 멤버 변수에 접근할 수 없다.

상위 클래스에 작성한 변수나 메서드 중 외부 클래스에서 사용할 수 없지만 하위 클래스에서는 사용할 수 있도록 지정하는 예약어가 protected이다.


하위 클래스가 생성될 때는 상위 클래스의 생성자가 먼저 호출된다. 
상속을 받은 하위 클래스는 상위 클래스의 변수와 메서드를 사용할 수 있다. 변수를 사용할 수 있다는 것은 그 변수를 저장하고 있는 메모리가 존재한다는 뜻이다. 그러나 하위 클래스에는 상위 클래스의 변수가 없다. 여기서 상속받은 하위 클래스가 생성되는 과정을 다시 생각할 필요가 있다.
상위 클래스를 상속받은 하위 클래스가 생성될 때는 반드시 상위 클래스의 생성자가 먼저 호출된다. 그리고 상위 클래스의 생성자가 호출될 때 상위 클래스의 멤버 변수가 메모리(힙 메모리)에 생성되는 것이다.
상위 클래스에서 private으로 선언한 변수도 물론 메모리에 올라간다 하지만 하위 클래스에서 접근할 수 없을 뿐이다.



super 예약어는 하위 클래스에서 상위 클래스로 접근할 때 사용한다. 하위 클래스는 상위 클래스의 주소, 즉 참조 값을 알고 있다. 이 참조 값을 가지고 있는 예약어가 super다. 또한 super는 상위 클래스의 생성자를 호출하는 데도 사용한다.
하위 클래스 생성자만 호출했는데 상위 클래스 생성자가 호출되는 이유는 하위 클래스 생성자에서 super()를 자동으로 호출하기 때문이다. super()를 호출하면 상위 클래스의 디폴트 생성자가 호출된다. 하위 클래스의 디폴트 생성자는 바이트 코드로 변환되기 전에 다음과 같이 코드가 자동으로 변경된다.(컴파일러가 자동으로 super();코드를 추가한다.)
public VIPCustomer() {
	super();//컴파일러가 자동으로 추가하는 코드. 상위 클래스의 Customer()가 호출됨
	...
}

하위 클래스가 생성될 때는 상위 클래스의 디폴트 생성자를 호출하는 super()가 자동으로 생성된다. 부모 클래스에서 디폴트 생성자를 없애고 자식 클래스의 생성자에서 명시적으로 부모 클래스의 생성자를 호출하지 않는다면 오류가 생긴다. 자식 클래스의 생성자에서는 먼저 부모 클래스의 생성자를 호출해야하기 때문이다. 원래 컴파일러가 자식 클래스의 생성자에서 부모클래스의 디폴트 생성자를 호출하도록 자동으로 코딩하지만 부모 클래스의 디폴트 생성자가 없기에 오류가 생기는 것이다. 이런 경우는 자식 클래스에서 super를 이용해 생성자를 명시적으로 호출해야한다.(코드로 써주어야한다.)
하위 클래스의 인스턴스를 만드는 경우 즉, 하위 클래스의 생성자가 호출되면 먼저 상위 클래스 생성자가 호출되고 상위 클래스 생성자 호출이 끝나면 하위 클래스 생성자의 내부 코드 수행이 마무리된다.

하위 클래스가 생성될 때는 상위 클래스의 생성자가 먼저 호출된다.
상위 클래스에 디폴트 생성자가 없고 매개변수가 있는 생성자만 있을 경우 super()에 매개변수를 추가하여, 매개변수가 있는 상위 클래스의 생성자를 직접 호출해야 한다.


상위 클래스에 선언한 멤버 변수나 메서드를 하위 클래스에서 참조할 때도 super를 사용한다. this를 사용하여 자신의 멤버에 접근했던 것과 비슷하다.
super() 예약어는 상위 클래스의 참조 값을 가지고 있다.
하위 클래스가 상위 클래스와 동일한 이름의 메서드를 구현하는 경우도 있다. 이러한 경우 하위 클래스에서 동일한 이름의 상위 클래스 메서드를 가리킬 때 super.메서드()라고 써야한다.



상위 클래스로 묵시적 클래스 형 변환
VIPCustomer는 VIPCustomer형이면서 동시에 Customer형이기도 하다. 즉 VIPCustomer클래스로 인스턴스를 생성할 때 이 인스턴스의 자료형을 Customer형으로 클래스 형 변환하여 선언할 수 있다. 왜냐하면 VIPCustomer클래스는 Customer클래스를 상속받았기 때문이다.
이러한 클래스 형 변환을 업캐스팅(upcasting)이라고 한다.

선언된 클래스형	생성된 인스턴스의 클래스형
(상위 클래스형)	(하위 클래스형)
Customer vc = new VIPCustomer();

반대로 Customer로 인스턴스를 생성할 때 VIPCustomer형으로 선언할 수는 없다. 상위 클래스인 Customer가 VIPCustomer 클래스의 기능을 다 가지고 있는 것은 아니기 때문이다. 
모든 하위 클래스는 상위 클래스 자료형으로 형변환될 수 있지만 그 역은 성립하지 않는다.
VIPCustomer는 상위 클래스 Customer형을 내포하고 있기 때문에 Customer형으로 형 변환될 수 있지만 그 역은 성립되지 않는다.


형변환된 vc가 가리키는 것
Customer vc = new VIPCustomer();에서 형 변환된 vc가 가리키는 것은?
클래스가 형 변환이 되었을 때는 선언한 클래스형에 기반하여 멤버 변수와 메서드에 접근할 수 있다. 따라서 이 vc 참조 변수가 가리킬 수 있는 변수와 메서드는 Customer 클래스의 멤버뿐이다.

하위 클래스의 인스턴스가 상위 클래스로 형 변환되는 과정이 묵시적으로 이루어진다.

클래스의 상속 계층이 여러 단계일 경우도 상위 클래스로의 형 변환은 묵시적으로 이루어진다. 
Mammal<-Primate<-Human
Primate aHuman = new Human();
Mammal mHuman = new Human();



메서드 오버라이딩(method overriding)
상위 클래스의 메서드를 하위 클래스에서 재정의하는 것
오버라이딩을 하려면 반환형, 메서드 이름, 매개변수 개수, 매개변수 자료형이 반드시 같아야 한다. 그렇지 않으면 자바 컴파일러는 재정의한 메서드를 기준 메서드와 다른 메서드로 인식한다.

@Override 애노테이션은 '이 메서드는 재정의된 메서드입니다'라고 컴파일러에 명확히 알려 주는 역할을 한다.

annotation: 주석
애노테이션은 영어로는 주석이라는 의미이다. @ 기호와 함께 사용하며 '@애노테이션 이름'으로 표현한다. 자바에서 제공하는 애노테이션은 컴파일러에게 특정한 정보를 제공해 주는 역할을 한다. 예를 들어 @Override는 이 메서드가 재정의된 메서드임을 컴파일러에게 알려준다. 만약 메서드의 선언부가 다르다면 컴파일 오류가 발생하여 프로그래머의 실수를 막아 준다. 이렇게 미리 정의되어 있는 애노테이션을 표준 애노테이션이라고 한다. 
@Override : 재정의된 메서드라는 정보 제공
@FunctionalInterface : 함수형 인터페이스라는 정보 제공
@Deprecated : 이후 버전에서 사용하지 않을 수 있는 변수, 메서드에 사용됨
@SuppressWarnings : 특정 경고가 나타나지 않도록 함



묵시적 클래스 형 변환과 메서드 재정의
멤버 변수와 메서드는 선언한 클래스형에 따라 호출된다.
상속에서 상위 클래스와 하위 클래스에 같은 이름의 메서드가 존재할 때 호출되는 메서드는 인스턴스에 따라 결정된다. 다시 말해 선언한 클래스형이 아닌 생성된 인스턴스의 메서드를 호출하는 것이다.



