익명 객체

구현 클래스가 매번 달라지거나, 한 번만 사용되는 경우, 굳이 구현 클래스를 생성하지 않고 익명 클래스로 선언할 수 있다.

interface Car {
	public void run();
}

public class Garage {
	public Car car = new Car() {
		@Override
		public void run() {
			System.out.println("달린다.");
		}
	}
}



람다식
함수적 프로그래밍

Y= f(x); 형태의 함수로 구성된 프로그래밍 기법

함수적 프로그래밍이 객체 지향 프로그래밍보다 효율적인 경우
1. 대용량 데이터의 처리시
2. 이벤트 지향 프로그램시

최근 프로그래밍 기법
객체지향프로그래밍 + 함수적 프로그래밍



람다식의 장점
코드가 간결해진다.
컬렉션 요소 처리가 쉬워진다.


자바의 람다식은 함수적 인터페이스의 익명 구현 객체를 대신한다.
람다식은 코드블럭을 메서드에 넣을 때 사용하는 기술이다.

함수적 인터페이스
추상 메서드가 1개인 인터페이스


public interface Say01 {
	public void talking();
}

public class Person {
	public void greeting(Say01 say){
		say.talking();
	}
}

방법 1. 익명 객체 방법
Person p = new Person();
p.greeting(new Say01(){
	public void talking() {
		System.out.println("안녕");
	}
});


방법 2. 람다식
Person pp = new Person();
pp.greeting( () -> {
	System.out.println("안녕");
});




반복자 스트림
컬렉션의 저장 요소를 하나씩 참조하도록 도와주는 반복자.
람다식으로 처리할 수 있도록 해주는 반복자이다.
파일 입출력 stream과는 다른 개념이다.
속도면에서 빠르다.

중간처리 메서드

distinct()
중복을 제거

filter()
매개값으로 주어진 predicate가 true를 리턴하는 요소만 필터링

mapXXX()
요소를 대체하는 요소로 구성된 새로운 스트림 리턴

sorted()
요소를 정렬


최종 처리메서드

forEach()
결과를 촐력할 때 사용

Collect()
컬렉션 객체를 List, Set, Map으로 변환처리할 때 사용한다.


list.stream().distinct().sorted().filter((t) -> t % 2 == 0).forEach((s) ->System.out.print(s + " "));
System.out.println("--------------------------------------");
		
		
// map() - 람다안에 정의된 새로운 stream타입으로 반환
list.stream().distinct().sorted().map(new Function<Integer, String>() {
	@Override
	public String apply(Integer t) {
		return t % 2 == 0 ? "짝수" : "홀수";
	}
}).forEach((s) -> System.out.print(s + " "));



정규표현식


1. Pattern 컴파일
2. Matcher
3. find






















